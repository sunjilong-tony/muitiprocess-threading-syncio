# coding= utf-8
"""
单核CPU执行多任务
操作系统可以同时运行多个任务，现在的操作系统都支持多任务的系统
时间片轮转（1us）
操作系统轮流让各个任务交替执行，反复执行，表面看每个任务都在交替执行，导致我们感觉好像所有的任务
都在执行
多核cpu执行多任务
并发
看上去一起执行，任务数量最多与cpu核心数
并行
真正一起执行任务数量最小于cpu核心数
实现多任务的方式：
1.多进程  启动多个进程，每个进程虽然自有1个线程，但是多个进程可以一起执行对个任务
2多线程  启动一个进程，在一个进程内部启动多个线程
3.多线程+多进程  启动多个进程，每个进程在启动多个线程
4.协程
5.多进程+协程
"""

"""
什么是进程（process）
对于一个操作系统，一个任务就是一个进程
p.start()：启动进程，并调用该子进程中的p.run() 
p.run():进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法  
p.terminate():强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。
如果p还保存了一个锁那么也将不会被释放，进而导致死锁
p.is_alive():如果p仍然运行，返回True
p.join([timeout]):主线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是可选的超时时间，需要强调的是，
p.join只能join住start开启的进程，而不能join住run开启的进程
"""
# p.daemon：默认值为False，如果设为True，代表p为后台运行的守护进程，当p的父进程终止时，p也随之终止，并且设定为True后，p不能创建自己的新进程，必须在p.start()之前设置
# p.name:进程的名称
# p.pid：进程的pid
# p.exitcode:进程在运行时为None、如果为–N，表示被信号N结束(了解即可)
# p.authkey:进程的身份验证键,默认是由os.urandom()随机生成的32字符的字符串。这个键的用途是为涉及网络连接的底层进程间通信提供安全性，这类连接只有在具有相同的身份验证键时才能成功（了解即可）
import time
from multiprocessing import Process, Queue


def girl(q):
    print("来自boy的信息>>>", q.get())
    print("来自班主任的凝视>>>", q.get())


def boy(q):
    q.put("中午一起吃饭吗?")


if __name__ == '__main__':
    q = Queue(5)
    boy_p = Process(target=boy, args=(q,))
    girl_p = Process(target=girl, args=(q,))
    boy_p.start()
    girl_p.start()
    time.sleep(1)  # 等待子进程执行完毕
    q.put("好好上课,别开小差!")

# 执行结果:
# 来自boy的信息>>> 中午一起吃饭吗?
# 来自班主任的凝视>>> 好好上课,别开小差!